CCEffect %{
  techniques:
  - passes:
    - vert: vs:vert
      frag: fs:frag

      # 2D Sprite 常规设置：不写深度、透明混合、不开背面剔除
      depthStencilState:
        depthTest: false
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      rasterizerState:
        cullMode: none

      # 材质面板可调参数（会自动绑定到 fragment 的 Constant uniform）
      properties:
        startColor: { value: [1, 1, 1, 1], editor: { type: color } }  # 渐变起始色
        endColor:   { value: [1, 1, 1, 1], editor: { type: color } }  # 渐变结束色
        params:     { value: [1, 0, 1, 0.2] } # x=horizontal, y=time, z=speed, w=amplitude
}%

CCProgram vs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>

  // Sprite 默认顶点输入：位置、UV、顶点色
  in vec3 a_position;
  in vec2 a_texCoord;
  in vec4 a_color;

  // 传给片元着色器：UV 和 顶点色
  out vec2 uv0;
  out vec4 color;

  vec4 vert () {
    // 直接透传 UV、顶点色
    uv0 = a_texCoord;
    color = a_color;

    // 直接用 VP 矩阵把本地坐标变到裁剪空间（最简路径）
    return cc_matViewProj * vec4(a_position, 1.0);
  }
}%

CCProgram fs %{
  precision highp float;
  #include <builtin/internal/embedded-alpha> // 提供 CCSampleWithAlphaSeparated，兼容分离 Alpha 纹理

  in vec2 uv0;
  in vec4 color;

  // properties 里的参数会自动映射到这里
  uniform Constant {
    vec4 startColor;   // 渐变起始色
    vec4 endColor;     // 渐变结束色
    vec4 params; // x horizontal, y time, z speed, w amplitude
  };

  // Sprite 默认纹理采样器（引擎约定 binding）
  #pragma builtin(local)
  layout(set = 2, binding = 11) uniform sampler2D cc_spriteTexture;

  vec4 frag () {
    float horizontal = params.x;
    float time = params.y;
    float speed = params.z;
    float amplitude = params.w;
    // 采样 sprite 纹理（含分离 alpha 处理）
    vec4 tex = CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);

    // 选择渐变方向：horizontal>=0.5 用 x，否则用 y
    // float axis = mix(uv0.y, uv0.x, step(0.5, horizontal));

    // 用 sin(time) 做动态扰动：
    // 1) sin 输出 [-1,1]，映射到 [0,1]
    // 2) amplitude 控制扰动强度
    float s = sin(time * speed);          // [-1, 1]
    float wobble = (s * 0.5 + 0.5);       // [0, 1]

    // 将动态项叠加到 axis 上，并 clamp 保证仍在 [0,1]
    // float t = clamp(axis + (wobble - 0.5) * 2.0 * amplitude, 0.0, 1.0);

    // 计算渐变颜色
    vec3 grad = mix(startColor.rgb, endColor.rgb, wobble);

    // 输出：纹理颜色 * 渐变 * 顶点色；alpha 保持为纹理alpha再乘顶点alpha
    return vec4(tex.rgb * grad, tex.a) * color;

    // return vec4(tex.rgb, tex.a) * color; // 原样输出图片
  }
}%